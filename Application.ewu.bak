$version 11.00

// This is the root component of the entire GUI application.
$rect <-240,160,-40,200>
$output false
class Navigation : Core::Group
{
  $rect <490,60,690,100>
  inherited property Bounds = <0,0,480,272>;

  $rect <20,20,160,60>
  object Application::NavigationBeat NavigationBeat
  {
    preset Bounds = <-1,-2,479,270>;
  }

  $rect <20,20,160,60>
  object Application::NavigationTempo NavigationTempo
  {
    preset Bounds = <1,-1,481,271>;
  }

  $rect <20,20,160,60>
  object Application::NavigationMetronom NavigationMetronom
  {
    preset Bounds = <-1,0,479,272>;
  }
}

$rect <30,100,230,140>
$output false
class SliderTempo : Core::Group
{
  $rect <500,10,700,50>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,480,272>;
    preset Bitmap = Application::MetronomeBackground;
    preset Opacity = 255;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <174,16,291,61>;
    preset String = "TEMPO";
    preset Font = Application::FontBodoni;
    preset Color = #2864FFFF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <360,65>;
    preset Point1 = <122,65>;
    preset Color = #04208BFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <91,111,291,161>;
    preset Outlet = ^Application::Device.Tempo;
    preset Unit = "";
    preset Precision = 0;
    preset CurrentBias = 0.0;
    preset Appearance = WidgetSet::ValueDisplay_Large;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob RotaryKnob
  {
    preset Bounds = <154,65,314,225>;
    preset Outlet = ^Application::Device.Tempo;
    preset StepSize = 5;
    preset MaxValue = 150;
    preset MinValue = 30;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <140,215,340,265>;
    preset Outlet = ^Application::Device.Tempo;
    preset StepSize = 5;
    preset MaxValue = 150;
    preset MinValue = 30;
    preset Appearance = Application::MyHorizontalSliderConfig;
  }
}

$rect <330,30,530,70>
$output false
resource Resources::Bitmap MetronomeBackground
{
  attr bitmapfile FileName = .\Res\wave-lines-white-vector-background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <880,29,1080,69>
$output false
resource Resources::Font FontBodoni
{
  attr fontname FontName = Bodoni MT;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <334,106,534,146>
$output false
resource Resources::Bitmap CheckIcon
{
  attr bitmapfile FileName = .\Res\Thumb - Copy.png;
  attr bitmapformat Format = Alpha8;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <30,60,230,100>
$output false
class SliderBeat : Core::Group
{
  $rect <510,0,710,40>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,360,210,400>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,310,210,350>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,480,272>;
    preset Bitmap = Application::MetronomeBackground;
    preset Opacity = 255;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <190,24,290,54>;
    preset String = "BEAT";
    preset Font = Application::FontBodoni;
    preset Color = #2864FFFF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <360,65>;
    preset Point1 = <122,65>;
    preset Color = #04208BFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <97,127,297,159>;
    preset Outlet = ^Application::Device.Beat;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob RotaryKnob
  {
    preset Bounds = <190,63,350,223>;
    preset Outlet = ^Application::Device.Beat;
    preset MaxValue = 8;
    preset MinValue = 2;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalSlider VerticalSlider
  {
    preset Bounds = <97,74,147,243>;
    preset Outlet = ^Application::Device.Beat;
    preset MaxValue = 8;
    preset MinValue = 2;
    preset Appearance = Application::MyVerticalSliderConfig;
  }
}

$rect <30,20,230,60>
$output false
class SliderMetronome : Core::Group
{
  $rect <500,10,700,50>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,480,272>;
    preset Bitmap = Application::MetronomeBackground;
    preset Opacity = 250;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton StartStop
  {
    preset Bounds = <205,86,275,156>;
    preset Visible = true;
    preset OnActivate = onStartPress;
    preset Icon = Application::PlayIcon;
    preset Label = "Caption";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay TempoValue
  {
    preset Bounds = <11,97,128,129>;
    preset Outlet = ^Application::Device.Tempo;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay BeatValue
  {
    preset Bounds = <291,97,413,129>;
    preset Outlet = ^Application::Device.Beat;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob TempoRotaryKnob
  {
    preset Bounds = <7,25,167,185>;
    preset Appearance = Application::RotaryMaxConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob BeatRotaryKnob
  {
    preset Bounds = <311,24,471,184>;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <510,60,710,100>
  slot onStartPress
  {
    trace "Metronome Start";

    Application::Device.Running= !   Application::Device.Running;

    StartStop.Icon= Application::Device.Running ? Application::StopIcon : Application::PlayIcon ;



  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ButtonTempo
  {
    preset Bounds = <15,195,165,245>;
    preset OnRelease = null;
    preset OnPress = null;
    preset Label = "TEMPO";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ButtonBeat
  {
    preset Bounds = <321,195,471,245>;
    preset OnRelease = null;
    preset OnPress = null;
    preset Label = "BEAT";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object Views::Text BeatTxt
  {
    preset Bounds = <36,201,154,231>;
    preset ColorBL = #3A61D4FF;
    preset String = "TEMPO";
    preset Font = Application::FontBodoni;
    preset Color = #3A61D4FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text TempoTxt
  {
    preset Bounds = <342,207,442,237>;
    preset String = "BEAT";
    preset Font = Application::FontBodoni;
    preset Color = #3A61D4FF;
    preset Visible = false;
  }
}

$rect <880,80,1080,120>
$output false
resource Resources::Font FontBodoniSmall
{
  attr fontname FontName = Bodoni MT;
  attr fontheight Height = 25;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <330,190,530,230>
$output false
resource Resources::Bitmap PlayIcon
{
  attr bitmapfile FileName = .\Res\PlayIcon.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// GUI components
note group Note
{
  attr Bounds = <-260,-20,270,460>;
}

// Assets
note group Note1
{
  attr Bounds = <320,-10,1150,580>;
}

$rect <329,269,529,309>
$output false
resource Resources::Bitmap ButtonFace
{
  attr bitmapfile FileName = .\Res\ButtonFace.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <-180,590,20,630>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Application::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */
}

$rect <-180,550,20,590>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Application::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  note arrow Note2
  {
    attr Point1 = <250,50>;
    attr Point2 = <320,50>;
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <220,120,420,160>
  property bool Running;

  $rect <620,120,820,160>
  onget Running
  {
    // Per default return the value stored already in the property.
    return pure Running;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <420,120,620,160>
  onset Running
  {
    // The property doesn't change -> nothing to do.
    if ( pure Running == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Running = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Running;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <20,120,220,160>
  $output true
  method void UpdateRunning( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Running )
    {
      // Remember the new value in the internal memory of the property.
      pure Running = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Running;
    }
  }

  $rect <220,170,420,210>
  property int32 Beat;

  $rect <620,170,820,210>
  onget Beat
  {
    // Per default return the value stored already in the property.
    return pure Beat;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <420,170,620,210>
  onset Beat
  {
    // The property doesn't change -> nothing to do.
    if ( pure Beat == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Beat = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Beat;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <20,170,220,210>
  $output true
  method void UpdateBeat( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Beat )
    {
      // Remember the new value in the internal memory of the property.
      pure Beat = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Beat;
    }
  }

  $rect <220,220,420,260>
  property int32 Tempo;

  $rect <620,220,820,260>
  onget Tempo
  {
    // Per default return the value stored already in the property.
    return pure Tempo;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <420,220,620,260>
  onset Tempo
  {
    // The property doesn't change -> nothing to do.
    if ( pure Tempo == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Tempo = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Tempo;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <20,220,220,260>
  $output true
  method void UpdateTempo( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Tempo )
    {
      // Remember the new value in the internal memory of the property.
      pure Tempo = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Tempo;
    }
  }
}

$rect <20,550,220,590>
autoobject Application::DeviceClass Device;

$rect <-180,630,60,670>
$variant $prototyper
vclass DeviceClassForPrototype : Application::DeviceClass
{
  $rect <20,110,220,150>
  inherited onset Running
  {
    super(value);

    if(value)
      trace "Started." ;
    else
      trace "Stop." ;
  }

  $rect <10,10,160,50>
  inherited onset Beat
  {
    super(value);
    trace "Beat set to " , value;
  }

  $rect <0,60,160,100>
  inherited onset Tempo
  {
    super(value);
    trace "Tempo set ", value;
  }
}

// Device
note group Note2
{
  attr Bounds = <-210,500,240,700>;
}

$rect <330,150,530,190>
$output false
resource Resources::Bitmap Thumb
{
  attr bitmapfile FileName = .\Res\Thumb.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <330,70,530,110>
$output false
resource Resources::Bitmap Track
{
  attr bitmapfile FileName = .\Res\Track.png;
  attr framesize FrameSize = <40,30>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <580,29,820,69>
$output false
autoobject WidgetSet::HorizontalSliderConfig MyHorizontalSliderConfig
{
  preset ThumbTintActive = #4A4EFFFF;
  preset ThumbTintDefault = #141547FF;
  preset ThumbActive = Application::Thumb;
  preset ThumbDefault = Application::Thumb;
  preset TrackRightTintActive = #B8B5E7E1;
  preset TrackRightTintDefault = #B8B5E7FF;
  preset TrackRightActive = Application::Track;
  preset TrackRightDefault = Application::Track;
  preset TrackLeftTintActive = #4A4EFFFF;
  preset TrackLeftTintDefault = #141547FF;
  preset TrackLeftActive = Application::Track;
  preset TrackLeftDefault = Application::Track;
}

$rect <580,69,820,109>
$output false
autoobject WidgetSet::VerticalSliderConfig MyVerticalSliderConfig
{
  preset ThumbTintActive = #4A4EFFFF;
  preset ThumbTintDefault = #141547FF;
  preset ThumbActive = Application::Thumb;
  preset ThumbDefault = Application::Thumb;
  preset TrackAboveTintActive = #BCBDFFB3;
  preset TrackAboveTintDefault = #BCBDFFFF;
  preset TrackAboveActive = Application::TrackVertical;
  preset TrackAboveDefault = Application::TrackVertical;
  preset TrackBelowTintActive = #4A4EFFFF;
  preset TrackBelowTintDefault = #141547FF;
  preset TrackBelowActive = Application::TrackVertical;
  preset TrackBelowDefault = Application::TrackVertical;
}

$rect <329,349,529,389>
$output false
resource Resources::Bitmap RotaryBackground
{
  attr bitmapfile FileName = .\Res\RotaryBackgroundOxygen.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <329,389,529,429>
$output false
resource Resources::Bitmap RotaryThumbMax
{
  attr bitmapfile FileName = .\Res\RotaryThumbMax.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <600,189,800,229>
$output false
autoobject WidgetSet::RotaryKnobConfig RotaryMaxConfig
{
  preset TrackRightColorActive = #141547FF;
  preset TrackRightColorDefault = #141547FF;
  preset CoverTintActive = #2B2D9AFF;
  preset CoverTintFocused = #141547FF;
  preset CoverTintDisabled = #141547FF;
  preset CoverTintDefault = #141547FF;
  preset ThumbMaxAngle = 2;
  preset ThumbMinAngle = 270;
  preset ThumbPivot = <80,80>;
  preset ThumbTintActive = #3B3DD2FF;
  preset ThumbTintDefault = #3B3DD2FF;
  preset ThumbActive = Application::RotaryThumbMax;
  preset ThumbFocused = Application::RotaryThumbMax;
  preset ThumbDefault = Application::RotaryThumbMax;
  preset ScaleTintActive = #2B2D9AFF;
  preset ScaleTintFocused = #4D8DFFFF;
  preset ScaleTintDisabled = #141547FF;
  preset ScaleTintDefault = #141547FF;
  preset ScaleActive = Application::RotaryBackground;
  preset ScaleFocused = Application::RotaryBackground;
  preset ScaleDisabled = Application::RotaryBackground;
  preset ScaleDefault = Application::RotaryBackground;
  preset WidgetMaxSize = <160,160>;
  preset WidgetMinSize = <160,160>;
}

$rect <320,429,520,469>
$output false
resource Resources::Bitmap RotaryThumbMin
{
  attr bitmapfile FileName = .\Res\RotaryThumbMin.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <600,229,800,269>
$output false
autoobject WidgetSet::RotaryKnobConfig RotaryMinConfig
{
  preset TrackRightColorActive = #8C81FFFF;
  preset TrackRightColorFocused = #8C81FFFF;
  preset TrackRightColorDisabled = #8C81FFFF;
  preset TrackRightColorDefault = #8C81FFFF;
  preset TrackLeftColorActive = #2B2D9AFF;
  preset TrackLeftColorFocused = #2B2D9AFF;
  preset TrackLeftColorDisabled = #2B2D9AFF;
  preset TrackLeftColorDefault = #2B2D9AFF;
  preset CoverTintActive = #2B2D9AFF;
  preset CoverTintFocused = #141547FF;
  preset CoverTintDisabled = #141547FF;
  preset CoverTintDefault = #141547FF;
  preset ThumbMaxAngle = 90;
  preset ThumbMinAngle = 358;
  preset ThumbPivot = <0,80>;
  preset ThumbTintActive = #2B2D9AFF;
  preset ThumbTintFocused = #2B2D9AFF;
  preset ThumbTintDisabled = #2B2D9AFF;
  preset ThumbTintDefault = #2B2D9AFF;
  preset ThumbActive = Application::RotaryThumbMin;
  preset ThumbFocused = Application::RotaryThumbMin;
  preset ThumbDefault = Application::RotaryThumbMin;
  preset ScaleTintActive = #2B2D9AFF;
  preset ScaleTintFocused = #141547FF;
  preset ScaleTintDisabled = #141547FF;
  preset ScaleTintDefault = #141547FF;
  preset ScaleActive = Application::RotaryBackground;
  preset ScaleFocused = Application::RotaryBackground;
  preset ScaleDisabled = Application::RotaryBackground;
  preset ScaleDefault = Application::RotaryBackground;
  preset WidgetMaxSize = <160,160>;
  preset WidgetMinSize = <160,160>;
}

// This object contains configuration information for a push button widget.
$rect <581,109,820,149>
$output false
autoobject WidgetSet::PushButtonConfig PushButtonConfig
{
  preset IconTintActive = #5EFF42FF;
  preset IconTintDefault = #5EFF42FF;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop];
  preset FaceTintActive = #525252FF;
  preset FaceTintDefault = #525252FF;
  preset FaceFrameActive = 1;
  preset FaceFrameFocused = 0;
  preset FaceFrameDefault = 0;
  preset FaceActive = Application::ButtonFace;
  preset FaceFocused = null;
  preset FaceDisabled = null;
  preset FaceDefault = Application::ButtonFace;
}

$rect <329,229,529,269>
$output false
resource Resources::Bitmap StopIcon
{
  attr bitmapfile FileName = .\Res\StopIcon.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <580,149,820,189>
$output false
autoobject WidgetSet::PushButtonConfig NavigationButton
{
  preset LabelColorActive = #2860FFFF;
  preset LabelColorDefault = #1840A3FF;
  preset IconTintActive = #64FF59FF;
  preset IconTintFocused = #FFFFFFFF;
  preset IconTintDisabled = #FFFFFFFF;
  preset IconTintDefault = #48B840FF;
  preset LabelFont = Application::FontBodoniSmall;
  preset FaceTintActive = #E0F5FFFF;
  preset FaceTintDisabled = #FFFFFFFF;
  preset FaceTintDefault = #F7FFF7FF;
  preset FaceActive = Application::NavigationButtonFace;
  preset FaceDefault = Application::NavigationButtonFace;
}

$rect <329,309,529,349>
$output false
resource Resources::Bitmap NavigationButtonFace
{
  attr bitmapfile FileName = .\Res\PushButton.png;
  attr bitmapformat Format = Alpha8;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <880,125,1080,165>
autoobject Graphics::AttrSet DarkBlueColor
{
  preset Bitmap0 = null;
  preset Color0 = #141547FF;
}

$rect <-240,230,-40,270>
$output false
class OnePageMetronom : Core::Group
{
  $rect <530,10,730,50>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <260,340,1040,660>;
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <0,0,482,272>;
    preset Bitmap = Application::MetronomeBackground;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay TempoValue
  {
    preset Bounds = <11,97,128,129>;
    preset Outlet = ^Application::Device.Tempo;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay BeatValue
  {
    preset Bounds = <291,97,413,129>;
    preset Outlet = ^Application::Device.Beat;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <205,86,275,156>;
    preset Visible = true;
    preset OnRelease = OnStartButtonPress;
    preset OnActivate = null;
    preset Icon = Application::PlayIcon;
    preset Label = "Caption";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ButtonTempo
  {
    preset Bounds = <15,195,165,245>;
    preset Visible = false;
    preset OnRelease = null;
    preset OnPress = null;
    preset Label = "TEMPO";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ButtonBeat
  {
    preset Bounds = <321,195,471,245>;
    preset Visible = false;
    preset OnRelease = null;
    preset OnPress = null;
    preset Label = "BEAT";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob TempoRotary
  {
    preset Bounds = <23,25,183,185>;
    preset Outlet = ^Application::Device.Tempo;
    preset Appearance = Application::RotaryMaxConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob BeatRotary
  {
    preset Bounds = <301,26,461,186>;
    preset Outlet = ^Application::Device.Beat;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <520,80,720,120>
  slot OnStartButtonPress
  {
    Application::Device.Running= !   Application::Device.Running;

    PushButton.Icon= Application::Device.Running ? Application::StopIcon : Application::PlayIcon ;



  }

  $rect <20,20,160,60>
  object Views::Text BeatTxt
  {
    preset Bounds = <36,201,154,231>;
    preset ColorBL = #3A61D4FF;
    preset String = "TEMPO";
    preset Font = Application::FontBodoni;
    preset Color = #3A61D4FF;
  }

  $rect <20,20,160,60>
  object Views::Text TempoTxt
  {
    preset Bounds = <342,207,442,237>;
    preset String = "BEAT";
    preset Font = Application::FontBodoni;
    preset Color = #3A61D4FF;
  }
}

$rect <-240,20,-40,60>
$output false
class NavigationMetronom : Core::Group
{
  $rect <530,10,730,50>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <260,340,1040,660>;
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <0,0,482,272>;
    preset Bitmap = Application::MetronomeBackground;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay TempoValue
  {
    preset Bounds = <11,97,128,129>;
    preset Outlet = ^Application::Device.Tempo;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay BeatValue
  {
    preset Bounds = <291,97,413,129>;
    preset Outlet = ^Application::Device.Beat;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <205,86,275,156>;
    preset Visible = true;
    preset OnRelease = OnStartButtonPress;
    preset OnActivate = null;
    preset Icon = Application::PlayIcon;
    preset Label = "Caption";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ButtonTempo
  {
    preset Bounds = <15,195,165,245>;
    preset OnRelease = onTempoPress;
    preset OnPress = null;
    preset Label = "TEMPO";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ButtonBeat
  {
    preset Bounds = <321,195,471,245>;
    preset OnRelease = onBeatPress;
    preset OnPress = null;
    preset Label = "BEAT";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob TempoRotary
  {
    preset Bounds = <23,25,183,185>;
    preset Outlet = null;
    preset Appearance = Application::RotaryMaxConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob BeatRotary
  {
    preset Bounds = <301,26,461,186>;
    preset Outlet = null;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <520,80,720,120>
  slot OnStartButtonPress
  {
    Application::Device.Running= !   Application::Device.Running;

    PushButton.Icon= Application::Device.Running ? Application::StopIcon : Application::PlayIcon ;



  }

  $rect <520,130,720,170>
  slot onTempoPress
  {
    var Core::Group tempo = new Application::NavigationTempo;
    // Present the Dialog now
    SwitchToDialog( tempo, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );

  }

  $rect <520,180,720,220>
  slot onBeatPress
  {
    var Core::Group beat = new Application::NavigationBeat;
     // Present the Dialog now
    SwitchToDialog( beat, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                               null, null,null, false );



  }
}

$rect <-240,60,-40,100>
$output false
class NavigationTempo : Core::Group
{
  $rect <500,10,700,50>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,480,272>;
    preset Bitmap = Application::MetronomeBackground;
    preset Opacity = 255;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <174,16,291,61>;
    preset String = "TEMPO";
    preset Font = Application::FontBodoni;
    preset Color = #2864FFFF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <360,65>;
    preset Point1 = <122,65>;
    preset Color = #04208BFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <91,111,291,161>;
    preset Outlet = ^Application::Device.Tempo;
    preset Unit = "";
    preset Precision = 0;
    preset CurrentBias = 0.0;
    preset Appearance = WidgetSet::ValueDisplay_Large;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob RotaryKnob
  {
    preset Bounds = <153,71,313,231>;
    preset Outlet = ^Application::Device.Tempo;
    preset StepSize = 5;
    preset MaxValue = 150;
    preset MinValue = 30;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <140,215,340,265>;
    preset Outlet = ^Application::Device.Tempo;
    preset StepSize = 5;
    preset MaxValue = 150;
    preset MinValue = 30;
    preset Appearance = Application::MyHorizontalSliderConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <387,207,462,257>;
    preset Opacity = 250;
    preset OnRelease = onCheck;
    preset OnPress = null;
    preset Icon = Application::CheckIcon;
    preset Label = "";
    preset Appearance = Application::NavigationButton;
  }

  $rect <500,70,700,110>
  slot onCheck
  {
    var Core::Group metronom= new Application::NavigationMetronom;
    SwitchToDialog( metronom, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }
}

$rect <-240,100,-40,140>
$output false
class NavigationBeat : Core::Group
{
  $rect <510,0,710,40>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,360,210,400>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,310,210,350>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,480,272>;
    preset Bitmap = Application::MetronomeBackground;
    preset Opacity = 255;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <190,24,290,54>;
    preset String = "BEAT";
    preset Font = Application::FontBodoni;
    preset Color = #2864FFFF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <360,65>;
    preset Point1 = <122,65>;
    preset Color = #04208BFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <97,127,297,159>;
    preset Outlet = ^Application::Device.Beat;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::RotaryKnob RotaryKnob
  {
    preset Bounds = <181,70,341,230>;
    preset Outlet = ^Application::Device.Beat;
    preset MaxValue = 8;
    preset MinValue = 2;
    preset Appearance = Application::RotaryMinConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <384,207,459,257>;
    preset Opacity = 250;
    preset OnRelease = onCheck;
    preset OnPress = null;
    preset Icon = Application::CheckIcon;
    preset Label = "";
    preset Appearance = Application::NavigationButton;
  }

  $rect <510,50,710,90>
  slot onCheck
  {
    var Core::Group metronom = new Application::NavigationMetronom;

    SwitchToDialog( metronom, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalSlider VerticalSlider
  {
    preset Bounds = <97,74,147,243>;
    preset Outlet = ^Application::Device.Beat;
    preset MaxValue = 8;
    preset MinValue = 2;
    preset Appearance = Application::MyVerticalSliderConfig;
  }
}

$rect <330,530,530,570>
$output false
resource Resources::Bitmap TrackVertical
{
  attr bitmapfile FileName = .\Res\TrackVertical.png;
  attr bitmapformat Format = Alpha8;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <30,160,230,200>
$output false
class Slider : Core::Group
{
  $rect <490,40,690,80>
  inherited method Init()
  {
    //idlesignal onInit;
    Outline.ScrollOffset = point( -SliderTempo.Bounds.w, 0 );
  }

  $rect <490,0,690,40>
  inherited property Bounds = <0,0,480,272>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,510,790,740>;
  }

  $rect <490,80,690,120>
  slot onInit
  {
    //Outline.EnsureVisible( SliderMetronome, true, null, null );
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,0,480,272>;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.LeftToRight;
  }

  $rect <20,20,160,60>
  object Application::SliderTempo SliderTempo
  {
    preset Bounds = <0,0,480,272>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::SliderMetronome SliderMetronome
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,0,480,272>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::SliderBeat SliderBeat
  {
    preset Bounds = <0,0,480,272>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,480,272>;
    preset SnapLast = <480,0>;
    preset SnapNext = <480,0>;
    preset SnapFirst = <480,0>;
    preset SlideVert = false;
    preset RubberBandEffectElasticity = 100.0;
    preset RubberBandEffectDuration = 100;
    preset RetargetDelay = 300;
    preset RetargetCondition = Core::RetargetReason[LongPress];
    preset Friction = 1.0;
    preset Embedded = false;
  }
}

$rect <30,230,230,270>
$output false
class Application : Core::Root
{
  $rect <490,0,690,40>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <490,50,690,90>
  slot onOpenMenu
  {
    // In order to avoid race conditions ignore the push button events if there
    // is already a menu presented
    if ( menu != null )
      return;

    // Create a new instance of the menu component
    menu = new Application::SettingsMenu;
    menu.OnOpenNavigaton = onNavigation;

    // ... and present it by using a fade-in transition
    AppContainer.PresentDialog( menu, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );


  }

  $rect <490,90,690,130>
  slot onNavigation
  {
    if ( menu != null )
    {
      //DismissDialog( menu, aOverrideDismissTransition, aOverrideOverlayTransition, aOverrideRestoreTransition, aComplete, aCancel, aCombine );
      menu = null;
    }


    var Core::Group page = new Application::Navigation;

    AppContainer.SwitchToDialog( page, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null, null,false );


  }

  $rect <801,194,1001,234>
  var Application::SettingsMenu menu = null;

  $rect <20,20,160,60>
  object Core::Group AppContainer
  {
    preset Bounds = <1,1,480,272>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <420,2,477,54>;
    preset OnRelease = onOpenMenu;
    preset Icon = Application::MenuFace;
    preset Label = "";
    preset Appearance = Application::NavigationButton;
  }
}

$rect <330,470,530,510>
$output false
resource Resources::Bitmap MenuFace
{
  attr bitmapfile FileName = .\Res\menuIcon.png;
  attr bitmapformat Format = Alpha8;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This component implements a generic menu.
$rect <880,230,1080,270>
$output false
class Menu : Templates::Menu
{
  $rect <20,410,220,450>
  inherited property Bounds = <0,0,300,220>;

  $rect <480,290,680,330>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    // This method is called always when something has changed in the
    // layout of the menu. In particular when items are added, removed,
    // hidden or shown. It is also called when the menu itself changes
    // its size.

    // In our template we want the menu to adjust its size automatically
    // to the number of available items. Doing this however directly in
    // context of the UpdateLayout() method would cause the UpdateLayout()
    // method to be executed recursively.

    // Therefore, we delay the adjust operation by using the 'postsignal'.
    // The adjust operation takes place in the slot method 'autoResize'.

    postsignal autoResize;
  }

  $rect <250,290,450,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the menu.
    //
    // isEnabled --> the menu can react to user inputs.
    // isModal   --> the menu is actually modal (it grabs all user inputs).
    // isFocused --> the menu can receive keyboard events.
    //
    var bool isEnabled = aState.contains( Core::ViewState[ Enabled ]);
    var bool isModal   = aState.contains( Core::ViewState[ Modal   ]);
    var bool isFocused = aState.contains( Core::ViewState[ Focused ]);


    /*

      TO DO:

      Depending on your menu design, you have surely added some new views
      to your menu. In the below code you should update the properties of
      these views. For example, when your menu has two images to appear
      exclusively for a focused or not focused menu, following can be done:

        imageFocused.Visible    =  isFocused;
        imageNotFocused.Visible = !isFocused;

      Depending on the state of the menu, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the menu
      (e.g. 'isFocused') with its preceding state (e.g. variable 'focused').

      Assuming you have already added to your menu component a new effect
      member, named it 'focusedEffect' and configured it to animate e.g. the
      opacity of an image within the menu. Then following is sufficient to
      trigger the animation:

        if ( isFocused && !focused )
        {
          focusedEffect.Reversed = false;
          focusedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          focusedEffect.Reversed = true;
          focusedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Color      = #444444FF;
      Border.Width      = 1;
      CaptionText.Color = #888888FF;
    }

    else if ( isFocused )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #000000FF;
      Border.Width      = 3;
      CaptionText.Color = #000000FF;
    }

    // Enabled but actually not focused for user interaction.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #000000FF;
      Border.Width      = 1;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // focused <<-->> not focused transition.
    enabled = isEnabled;
    focused = isFocused;
    modal   = isModal;
  }

  // To do:
  // 
  // - If necessary adjust the visible size of your menu (the thick blue border).
  // - Move and resize the members 'Outline' and 'SlideTouchHandler' so they determine \
  // the area where the menu items are displayed..
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your menu.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired menu design add and configure new views (e.g. an \
  // image view to show an icon in the menu, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the menu's current state.
  // - You can also add and configure animation effects to your menu. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your menu.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the menu itself is resized.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // menu to be activated with other keys than the 'Up', 'Down', etc. keys.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard navigation.
  // - From the Gallery folder 'Chora' add properties to your menu. One property \
  // for every menu specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your menu where \
  // the icon is shown).
  // - Take a look inside the 'autoResize' method. It calculates from the actual \
  // number of items the size of the entire menu. In this manner the menu can adjust \
  // its size automatically. This method can also calculate the position of the menu \
  // within its owner. Modify the method to your particular menu design.
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note4
  {
    attr Bounds = <10,470,990,900>;
  }

  // Layout management
  note group Note3
  {
    attr Bounds = <470,250,690,380>;
  }

  // State management
  note group Note2
  {
    attr Bounds = <240,250,460,460>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,250,230,380>;
  }

  // This variable stores the current state of the menu. Please see the comments \
  // inside UpdateViewState().
  $rect <250,410,450,450>
  var bool focused;

  // This variable stores the current state of the menu. Please see the comments \
  // inside UpdateViewState().
  $rect <250,370,450,410>
  var bool modal;

  // This variable stores the current state of the menu. Please see the comments \
  // inside UpdateViewState().
  $rect <250,330,450,370>
  var bool enabled;

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <20,290,220,330>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onPressKey;
  }

  // This slot method is called at the runtime after items have been added, removed, \
  // etc. Its job is to adapt the menu size to the of the items. In this manner the \
  // menu can resize itself according to the number of items within the menu.
  $rect <480,330,680,370>
  slot autoResize
  {
    // When you are editing the menu content in Composer, the automatic
    // adjustment would probably confuse you. Therefore, we test whether
    // 'this' component is actually opened in Composer. If 'true', we
    // leave the method immediately.

    $if $composer
      // Do we edit 'this' component in Composer? EwIsPrimaryObject() is
      // an internal function of Prototyper permitting to test whether
      // 'this' component is actually edited in Composer.
      if ( EwIsPrimaryObject( this ))
        return;
    $endif

    // In order to estimate the smallest possible width of the menu ...
    var int32      width;
    var Core::View view;

    // iterate over all visible items 
    while ( !!( view = Outline.FindNextView( view, Core::ViewState[ Visible ])))
    {
      var Core::Group item  = (Core::Group)view;
      width = math_max( width, item? item.GetMinimalSize().x : 0 );
    }

    // Determine the area occupied by all items
    var point s = Outline.GetContentArea( Core::ViewState[ Visible ]).size;

    // Use the previously estimated min width for the menu items
    s.x = width;

    // Take in account the area occupied by caption and borders. This can be
    // calculated from the difference between the actual size of the complete
    // menu and the size of the Outline area.
    s = s + Bounds.size - Outline.Bounds.size;

    // Ensure the menu is large enough to display at least the caption text
    // with an additional border around it.
    var point ts = CaptionText.GetContentArea().size + <20,20>;

    if ( s.x < ts.x ) s.x = ts.x;
    if ( s.y < ts.y ) s.y = ts.y;

    // Limit the max. menu size to e.g. 60% size of the screen size
    var int32 maxW = ( $ScreenSize.x * 3 ) / 5;
    var int32 maxH = ( $ScreenSize.y * 3 ) / 5;

    if ( s.x > maxW ) s.x = maxW;
    if ( s.y > maxH ) s.y = maxH;

    // Change the size of the menu
    Bounds.size = s;

    /*

      TO DO:

      If desired, you can also adjust the position of the menu so that it, for example,
      appears screen centered.

        Bounds = rect(<0,0>, s ) + point(( $ScreenSize.x - s.x ) / 2,
                                         ( $ScreenSize.y - s.y ) / 2 ); 

    */
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <20,330,220,370>
  slot onPressKey
  {
    var Core::Direction dir  = Core::Direction.None;
    var Core::View      item = Focus;

    // Determine the direction to look for other items to select
    switch ( KeyHandler.Code )
    {
      case Core::KeyCode.Left  : dir = Core::Direction.Left;
      case Core::KeyCode.Right : dir = Core::Direction.Right;
      case Core::KeyCode.Up    : dir = Core::Direction.Top;
      case Core::KeyCode.Down  : dir = Core::Direction.Bottom;
      default:;
    }

    // Look for the neighbor item accordingly the determined direction
    item = FindViewInDirection( item, dir, Core::ViewState[ Enabled, Focusable ]);

    // If found -> pass the focus to it
    // In case of large menus - scroll to the item with an animation effect
    if ( item != null )
    {
      Focus = item;

      // Prepare the animation effect. If you don't want the scroll animation,
      // just remove the following 3 lines and pass 'null' in the EnsureVisible()
      // method instead of 'effect'.
      var Effects::PointEffect effect = new Effects::PointEffect;

      effect.Timing        = Effects::Timing.FastIn_EaseOut;
      effect.CycleDuration = 100;

      // Scroll to the item
      Outline.EnsureVisible( item, true, effect, null );
    }
  }

  $rect <330,50,530,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the menu
    CaptionText.String = value;

    // Changing the caption can also affect the width of the
    // menu itself. Therefore trigger the routine to recalculate
    // the menu size
    postsignal autoResize;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,220>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,220>;
    preset Width = 3;
  }

  // This is a slide gesture handler. It allows the user to scroll the items within \
  // a large menu by touching the menu with the mouse or with the finger on a touch \
  // screen.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,40,290,210>;
    preset SlideHorz = false;
    preset Friction = 0.01;
  }

  // This is an outline view to group and scroll the items together.
  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,40,290,210>;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <10,0,290,40>;
    preset String = "Menu";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  // The property 'Caption' stores the text to display within the menu. 
  $rect <330,10,530,50>
  property string Caption = "Menu";
}

// This component implements a simple menu item.
$rect <880,270,1080,310>
$output false
class MenuItem : Templates::MenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for the caption and 20 pixel margin on
    // the left and on the right of the caption. Important: perform the calculation
    // without the caption text being evtl. truncated and replaced by an ellipsis
    // sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 20, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #FF0000FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your item.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon in the item, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Adapt the method GetMinimalSize(). The method should calculate the minimal \
  // width the item will occupy within the menu.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,370,990,780>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 3;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,210,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <480,10,680,50>
  property slot OnActivate = null;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a simple menu item. When activating the item a sub menu \
// is shown.
$rect <880,310,1080,350>
$output false
class OpenMenuItem : Templates::OpenMenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for the caption, 10 pixel margin on
    // its left side and some space for the arrow image on the right.
    // Important: perform the calculation without the caption text being evtl.
    // truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 10 + ArrowImage.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
      ArrowImage.Color  = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #FF0000FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
      ArrowImage.Color  = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
      ArrowImage.Color  = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
      ArrowImage.Color  = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Activation
  note group Note7
  {
    attr Bounds = <930,250,1150,340>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's new area.
  // - Remove the 'Background', 'Border' and 'ArrowImage' members if you want other \
  // views to be shown instead these in your item.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon in the item, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Adapt the method GetMinimalSize(). The method should calculate the minimal \
  // width the item will occupy within the menu.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Adapt the method 'openSubMenu' and specify the animations to perform when \
  // presenting the sub-menu.
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,370,990,800>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the the item has been activated. Thereupon \
  // the sub menu is opened and presented.
  $rect <940,290,1140,330>
  slot openSubMenu
  {
    /*

      The following code creates a new instance of the menu GUI component specified in the property
      'SubMenuClass' and presents the component as dialog.

      HINT :

      Depending on your design requirements you can modify the PresentDialog() invocation in order
      to determine the animations to show/hide the menu. Actually, the following implementation
      hides the superior menu when entering the sub-menu. If you don't want it, remove the expression
      'Effects::ShowHideCentered' and replace it by 'null'. In this manner the superior will remain
      visible while the sub-menu is active.

    */
    if ( Owner && Owner.IsCurrentDialog() && SubMenuClass )
      GetRoot().PresentDialog((Core::Group)new SubMenuClass, null, null, null, null, Effects::ShowHideCentered, null, null, null, false );
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal openSubMenu;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal openSubMenu;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }
  }

  $rect <450,50,650,90>
  onset SubMenuClass
  {
    // Verify, whether the assigned class descends from Core::Group
    if ( value && !(Core::Group)value )
      throw "The specified SubMenuClass does not descend from Core::Group.";

    // Store the new state ...
    pure SubMenuClass = value;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 3;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,193,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ArrowImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <193,0,220,40>;
    preset Color = #000000FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  // The property 'SubMenuClass' determines the menu GUI component to create and \
  // present when the user activates the menu item.
  $rect <450,10,650,50>
  property class SubMenuClass = null;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

$rect <-239,325,-39,365>
$output false
class SettingsMenu : Application::Menu
{
  $rect <20,20,160,60>
  inherited object Outline
  {
    preset Bounds = <10,40,290,208>;
  }

  $rect <20,20,160,60>
  inherited object CaptionText
  {
    preset String = "Style";
  }

  $rect <20,20,160,60>
  object Application::MenuItem SinglePage
  {
    preset Bounds = <28,45,248,85>;
    preset OnActivate = onSinglePage;
    preset Caption = "SinglePage";
  }

  $rect <20,20,160,60>
  object Application::MenuItem Navigation
  {
    preset Bounds = <27,92,247,132>;
    preset OnActivate = onNavigation;
    preset Caption = "Navigation";
  }

  $rect <20,20,160,60>
  object Application::MenuItem Slider
  {
    preset Bounds = <27,140,247,180>;
    preset OnActivate = onSlider;
    preset Caption = "Slider";
  }

  $rect <343,61,543,101>
  slot onSinglePage
  {
    var Core::Group page = new Application::OnePageMetronom;

    SwitchToDialog( page, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }

  $rect <340,110,540,150>
  slot onNavigation
  {
    signal OnOpenNavigaton;

  }

  $rect <340,160,540,200>
  slot onSlider
  {
    var Core::Group page = new Application::Slider;

    SwitchToDialog( page, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }

  $rect <640,0,840,40>
  property slot OnOpenNavigaton;
}

$rect <30,310,230,350>
$output false
class Settings : Core::Group
{
  $rect <500,-10,700,30>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <326,103,476,153>;
    preset OnRelease = Slot1;
    preset Label = "Navigation";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <324,163,474,213>;
    preset OnRelease = Slot2;
    preset Label = "Slider";
    preset Appearance = Application::NavigationButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <327,48,477,98>;
    preset OnRelease = Slot;
    preset Label = "One Page";
    preset Appearance = Application::NavigationButton;
  }

  $rect <510,50,710,90>
  slot Slot
  {
    var Core::Group page = new Application::OnePageMetronom;

    SwitchToDialog( page, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }

  $rect <510,100,710,140>
  slot Slot1
  {
    var Core::Group page = new Application::Navigation;

    SwitchToDialog( page, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }

  $rect <510,150,710,190>
  slot Slot2
  {
    var Core::Group page = new Application::Slider;

    SwitchToDialog( page, Effects::FadeInOutCentered, Effects::FadeInOutCentered, null, null, null, null,
                                null, null,null,false );
  }
}
